{"version":3,"file":"cqueue.min.js","sources":["cqueue.js"],"names":["undefined","Promise","require","global","deferred","promise","pCatch","pResolve","pReject","pThen","resolve","reject","apply","arguments","then","catch","Channel","this","queue","channel","prototype","constructor","put","arg","defer","length","push","take","pop","version","exports","module","define","cqueue"],"mappings":";;;;AAUA,GAAiBA,SAAZC,QACJ,GAAIA,SAAUC,QAAS,eAAgBD,SAGxC,SAAaE,EAAQF,SACrB,YAQA,SAASG,KACR,GAAIC,GAASC,EAAQC,EAAUC,EAASC,CAexC,OAbAJ,GAAU,GAAIJ,SAAS,SAAWS,EAASC,GAC1CJ,EAAWG,EACXF,EAAWG,IAGZL,EAAS,WACR,MAAOD,GAAQ,SAASO,MAAOP,EAASQ,YAGzCJ,EAAQ,WACP,MAAOJ,GAAQS,KAAKF,MAAOP,EAASQ,aAG7BE,QAAST,EAAQI,QAASH,EAAUI,OAAQH,EAASM,KAAML,GAkBpE,QAASO,WACRC,KAAKC,SAVN,GAAIC,GAAU,WACb,MAAO,IAAIH,SAaZA,SAAQI,UAAUC,YAAcL,QAShCA,QAAQI,UAAUE,IAAM,SAAWC,GAClC,GAAIC,GAAQpB,GAUZ,OARMa,MAAKC,MAAMO,OAKhBD,EAAMd,SAAU,QAAS,QAJzBO,KAAKC,MAAMQ,KAAMH,GACjBC,EAAMd,SAAU,WAAY,QAMtBc,GASRR,QAAQI,UAAUO,KAAO,WACxB,GAAIH,GAAQpB,GASZ,OAHCoB,GAAMd,QAJDO,KAAKC,MAAMO,QAIA,WAAYR,KAAKC,MAAMU,QAHvB,QAAS,OAMnBJ,GAQRR,QAAQI,UAAUS,QAAU,QAGL,mBAAXC,SACXC,OAAOD,QAAUX,EAES,kBAAVa,QAChBA,OAAQ,WACP,MAAOb,KAIRhB,EAAO8B,OAASd,GAEZF,KAAMhB","sourcesContent":["/**\n * Channel queue with Promises\n *\n * @author Jason Mulligan <jason.mulligan@avoidwork.com>\n * @copyright 2014 Jason Mulligan\n * @license BSD-3 <https://raw.github.com/avoidwork/cqueue/master/LICENSE>\n * @link http://avoidwork.github.io/cqueue\n * @module cqueue\n * @version 0.1.2\n */\nif ( Promise === undefined ) {\n\tvar Promise = require( \"es6-promise\" ).Promise;\n}\n\n( function ( global, Promise ) {\n\"use strict\";\n\n/**\n * \"Unboxed\" Promise factory\n *\n * @method deferred\n * @return {Object} Deferred\n */\nfunction deferred () {\n\tvar promise, pCatch, pResolve, pReject, pThen;\n\n\tpromise = new Promise( function ( resolve, reject ) {\n\t\tpResolve = resolve;\n\t\tpReject  = reject;\n\t} );\n\n\tpCatch = function () {\n\t\treturn promise[\"catch\"].apply( promise, arguments );\n\t};\n\n\tpThen = function () {\n\t\treturn promise.then.apply( promise, arguments );\n\t};\n\n\treturn {\"catch\": pCatch, resolve: pResolve, reject: pReject, then: pThen};\n}\n\n/**\n * Channel factory\n *\n * @method channel\n * @return {Object} Channel instance\n */\nvar channel = function () {\n\treturn new Channel();\n};\n\n/**\n * Channel\n *\n * @constructor\n */\nfunction Channel () {\n\tthis.queue = [];\n}\n\n// Setting constructor loop\nChannel.prototype.constructor = Channel;\n\n/**\n * Puts an item into the Channel\n *\n * @method put\n * @param  {Mixed} arg Item\n * @return {Array}     Deferred\n */\nChannel.prototype.put = function ( arg ) {\n\tvar defer = deferred();\n\n\tif ( !this.queue.length ) {\n\t\tthis.queue.push( arg );\n\t\tdefer.resolve( [\"continue\", null] );\n\t}\n\telse {\n\t\tdefer.resolve( [\"pause\", null] );\n\t}\n\n\treturn defer;\n};\n\n/**\n * Takes an item from the Channel\n *\n * @method take\n * @return {Array} Deferred\n */\nChannel.prototype.take = function () {\n\tvar defer = deferred();\n\n\tif ( !this.queue.length ) {\n\t\tdefer.resolve( [\"pause\", null] );\n\t}\n\telse {\n\t\tdefer.resolve( [\"continue\", this.queue.pop()] );\n\t}\n\n\treturn defer;\n};\n\n/**\n * Version property\n *\n * @type {String}\n */\nChannel.prototype.version = \"0.1.2\";\n\n// Node, AMD & window supported\nif ( typeof exports != \"undefined\" ) {\n\tmodule.exports = channel;\n}\nelse if ( typeof define == \"function\" ) {\n\tdefine( function () {\n\t\treturn channel;\n\t} );\n}\nelse {\n\tglobal.cqueue = channel;\n}\n} )( this, Promise );\n"]}